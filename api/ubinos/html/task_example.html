<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ubinos: 태스크 예제</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ubinos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">ubinos API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">태스크 예제 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tasktest00_sec"></a>
간단한 태스크 사용 예제 Simple task example</h1>
<ul>
<li><a href="tasktest00_8c-example.html">tasktest00.c</a></li>
</ul>
<p>이 예제는 간단한 메시지를 반복적으로 출력하는 태스크를 하나 생성한다.<br  />
 <br  />
</p>
<h1><a class="anchor" id="tasktest01_sec"></a>
태스크의 기본 기능 시험</h1>
<p>Test on basic functions of task</p>
<ul>
<li><a href="tasktest01_8c-example.html">tasktest01.c</a></li>
</ul>
<p>이 예제는 아래에 나열된 태스크의 기본 기능을 시험한다.</p>
<ul>
<li>태스크를 생성하는 기능</li>
<li>태스크가 종료될 때까지 기다리는 기능 <br  />
</li>
</ul>
<h1><a class="anchor" id="tasktest02_sec"></a>
태스크의 휴면sleep 기능 시험 Test on sleep function of task</h1>
<ul>
<li><a href="tasktest02_8c-example.html">tasktest02.c</a></li>
</ul>
<p>이 예제는 태스크의 휴면sleep 기능을 시험한다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 1에서 태스크 1을 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 1에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 2에서 태스크 1이 시점 3까지 휴면sleep을 시도한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 2에서 태스크 1이 수행 중이 아니어야(대기block 상태여야) 한다.<br  />
</p>
<p>시점 3이되면 태스크 1이 휴면sleep 시간이 다해서 깨어난다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 1이 종료된다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest02.gif" alt=""/>
</div>
<p> <br  />
</p>
<h1><a class="anchor" id="tasktest03_sec"></a>
태스크의 중지suspend 및 재시작resume 기능 시험 Test on suspend and resume function of task</h1>
<ul>
<li><a href="tasktest03_8c-example.html">tasktest03.c</a></li>
</ul>
<p>이 예제는 태스크의 중지suspend 및 재시작resume 기능을 시험한다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 1에서 태스크 1을 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 1에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 2에서 태스크 1을 중지suspend한다. <br  />
 여기까지 성공적으로 진행되었다면 확인 지점 2에서 태스크 1이 수행 중이 아니어야(중지suspended 상태여야) 한다.<br  />
</p>
<p>시점 3에서 태스크 1을 재시작resume한다. <br  />
 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 1이 스스로 중지suspend한다. <br  />
 여기까지 성공적으로 진행되었다면 확인 지점 4에서 태스크 1이 수행 중이 아니어야(중지suspended 상태여야) 한다.<br  />
</p>
<p>시점 5에서 태스크 1을 재시작resume한다. <br  />
 여기까지 성공적으로 진행되었다면 확인 지점 5에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 6에서 태스크 1이 종료된다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest03.gif" alt=""/>
</div>
<p> <br  />
</p>
<h1><a class="anchor" id="tasktest04_sec"></a>
우선순위 기반 멀티태스킹 기능 시험 Test on priority-based multi-tasking</h1>
<ul>
<li><a href="tasktest04_8c-example.html">tasktest04.c</a></li>
</ul>
<p>이 예제는 우선순위 기반 멀티태스킹 기능을 시험한다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 1에서 낮은 우선순위로 태스크 4를 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 1에서 태스크 4가 수행 중이어야 한다.<br  />
</p>
<p>시점 2에서 높은 우선순위로 태스크 1을 생성한다.<br  />
 태스크 1의 우선순위가 태스크 4의 우선순위 보다 높다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 2에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 3에서 중간 우선순위로 태스크 2와 3을 생성한다.<br  />
 태스크 1의 우선순위가 태스크 2와 3의 우선순위 보다 높다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 1이 종료된다.<br  />
 그러면 태스크 2와 3이 가장 높은 우선순위를 가진 태스크가 된다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 4에서 태스크 2와 3이 수행 중이어야 한다.<br  />
 태스크 2와 3은 같은 우선순위를 가지므로 라운드 로빈 방식으로 동시에 수행된다.<br  />
</p>
<p>시점 5에서 태스크 2와 3이 종료된다.<br  />
</p>
<p>시점 6에서 태스크 4가 종료된다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest04.gif" alt=""/>
</div>
<p> <br  />
</p>
<h1><a class="anchor" id="tasktest05_sec"></a>
태스크의 우선순위 설정 기능 시험 Test on set priority function of task</h1>
<ul>
<li><a href="tasktest05_8c-example.html">tasktest05.c</a></li>
</ul>
<p>이 예제는 태스크의 우선순위 설정 기능을 시험한다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 1에서 낮은 우선순위로 태스크 2를 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 1에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 2에서 중간 우선순위로 태스크 1을 생성한다.<br  />
 태스크 1의 우선순위가 태스크 2의 우선순위보다 높다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 2에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 3에서 태스크 2의 우선순위를 높은 우선순위로 설정한다.<br  />
 그러면 태스크 2의 우선순위가 태스크 1의 우선순위보다 높아진다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 2의 우선순위를 낮은 우선순위로 설정한다.<br  />
 그러면 태스크 1의 우선순위가 태스크 2의 우선순위보다 높아진다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 4에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 5에서 태스크 1이 종료된다.<br  />
</p>
<p>시점 6에서 태스크 2가 종료된다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest05.gif" alt=""/>
</div>
<p> <br  />
</p>
<h1><a class="anchor" id="tasktest06_sec"></a>
태스크에 의한 메모리 누수 시험 Test for memory leak by task</h1>
<ul>
<li><a href="tasktest06_8c-example.html">tasktest06.c</a></li>
</ul>
<p>이 예제는 태스크에 의한 메모리 누수를 시험한다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>먼저 힙heap의 할당된 메모리 총량과 메모리 블록 수를 가져와 저장한다.<br  />
 그리고 태스크 생성과 제거를 여러 번 반복한다.<br  />
 그 다음 힙heap의 할당된 메모리 총량과 메모리 블럭 수를 다시 가져와 저장했던 값과 비교한다.<br  />
 메모리 누수가 발생하지 않았다면 저장했던 값과 다시 가져온 값이 같아야 한다.<br  />
 <br  />
</p>
<h1><a class="anchor" id="tasktest07_sec"></a>
태스크의 다수 신호 객체 기다리기 기능 시험 Test on wait for multiple signal objects function of task</h1>
<ul>
<li><a href="tasktest07_8c-example.html">tasktest07.c</a></li>
</ul>
<p>이 예제는 태스크의 다수 신호 객체 기다리기 기능을 시험한다.<br  />
 태스크의 다수 신호 객체 기다리기 기능은 세마포어, 뮤텍스, 메시지큐, 시그널, 조건변수condition variable, 입출력버퍼 등 다양한 종류의 신호 객체 여러 개로부터 신호를 동시에 기다려야 할 경우 사용한다.<br  />
 이 기능을 사용해 다수 신호 객체를 기다리는 태스크는 기다림을 끝낼 조건으로 다음 두가지 중 하나를 선택할 수 있다.<br  />
 첫 번째는 기다리는 신호 객체들 중 하나 이상으로부터 신호를 받는 것이고, 두 번째는 기다리는 신호 객체들 모두로부터 신호를 받는 것이다.<br  />
 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하고 이 기능을 사용하면 두 번째가, 그렇지 않으면 첫 번째가 기다림을 끝낼 조건이 된다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 3에서 태스크 1이 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하지 않고 다수 신호 객체 기다리기를 시도한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 2가 태스크 1이 기다리고 있는 신호 객체들 중 하나에게 신호를 보낸다.<br  />
 그러면 태스크 1이 그 신호를 받고 깨어난다.<br  />
 이는 태스크 1이 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하지 않고 다수 신호 객체를 기다리고 있기 때문이다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 4에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 5에서 태스크 1이 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하고 다수 신호 객체 기다리기를 시도한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 5에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 6에서 태스크 2가 태스크 1이 기다리고 있는 신호 객체들 중 하나에게 신호를 보낸다.<br  />
 그러면 태스크 1이 그 신호를 받는다. 그러나 태스크 1이 깨어나지는 않는다.<br  />
 이는 태스크 1이 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하고 다수 신호 객체를 기다리고 있기 때문이다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 6에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 7에서 태스크 2가 태스크 1이 기다리고 있는 나머지 모든 신호 객체들에게 신호를 보낸다.<br  />
 그러면 태스크 1이 그 신호들을 받고 깨어난다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 7에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 10에서 태스크 1이 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하고 시점 12까지를 제한 시간으로 두고 다수 신호 객체 기다리기를 시도한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 10에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 11에서 태스크 2가 태스크 1이 기다리고 있는 신호 객체들 중 하나에게 신호를 보낸다.<br  />
 그러면 태스크 1이 그 신호를 받는다. 그러나 태스크 1이 깨어나지는 않는다.<br  />
 이는 태스크 1이 모두 기다리기 선택 사항(TASK_WAITOPT__ALL)을 선택하고 다수 신호 객체를 기다리고 있기 때문이다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 11에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 12가 되면 태스크 1이 제한 시간이 다해서 기다리는 모든 신호 객체들로부터 신호를 받지 못했더라도 깨어난다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 12에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest07.gif" alt=""/>
</div>
<p> <br  />
</p>
<h1><a class="anchor" id="tasktest08_sec"></a>
태스크의 남은 제한 시간 가져오기 기능 시험 Test on get remaining timeout tick function of task</h1>
<ul>
<li><a href="tasktest08_8c-example.html">tasktest08.c</a></li>
</ul>
<p>이 예제는 남은 제한 시간을 가져오는 기능을 시험한다.<br  />
 제한 시간을 두고 신호 객체를 기다리는 태스크가 제한 시간이 다하기 전에 신호를 받고 깨어났을 때, 이 기능을 사용하면 남은 제한 시간을 알아낼 수 있다.<br  />
 이 기능은 비 동기적으로 들어오는 신호 여러 개를 순차적으로 받아 처리하는 작업에 제한 시간을 두어야 할 경우 유용하다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 1에서 중간 우선순위로 태스크 2를 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 1에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 2에서 높은 우선순위로 태스크 1을 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 2에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 3에서 태스크 1이 시점 6까지를 제한 시간으로 두고 첫 번째 신호를 기다린다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 2가 첫 번째 신호를 보낸다.<br  />
 그러면 태스크 1이 그 신호를 받고 깨어난다.<br  />
 그리고 깨어난 태스크 1은 남은 제한 시간을 가져온다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 4에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 5에서 태스크 1이 가져온 남은 제한 시간과 이미 알고 있는 시점 4와 5 사이의 작업 시간을 가지고 시점 6까지 남은 시간을 계산한다.<br  />
 그리고 계산한 남은 시간을 활용해 다시 시점 6까지를 제한 시간으로 두고 두 번째 신호를 기다린다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 5에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 6이되면 태스크 1이 제한 시간이 다해서 신호를 받지 못했더라도 깨어난다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 6에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 7에서 태스크 1이 종료된다.<br  />
</p>
<p>시점 8에서 태스크 2가 종료된다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest08.gif" alt=""/>
</div>
<p> <br  />
</p>
<h1><a class="anchor" id="tasktest09_sec"></a>
태스크 중지suspend 및 재시작resume 기능 시험 2 Test 2 on suspend and resume function of task</h1>
<ul>
<li><a href="tasktest09_8c-example.html">tasktest09.c</a></li>
</ul>
<p>이 예제는 태스크를 중지suspend했다가 재시작resume했을 때, 태스크 상태가 중지suspend하기 직전 상태로 돌아가는지를 시험한다.<br  />
 시험 과정은 다음과 같다.<br  />
</p>
<p>시점 1에서 중간 우선순위로 태스크 2를 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 1에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 2에서 높은 우선순위로 태스크 1을 생성한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 2에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 3에서 태스크 1이 신호를 기다린다(대기blocked 상태가 된다).<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 3에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 4에서 태스크 2가 태스크 1을 중지suspend한 후 신호를 보낸다.<br  />
 중지suspend된 태스크는 신호를 받지 못한다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 4에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 5에서 태스크 2가 태스크 1을 재시작resume한다.<br  />
 재시작resume되 태스크 1은 시점 4에서 보내진 신호를 받고 깨어난다(준비ready 상태가 된다).<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 5에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 6에서 태스크 1이 시점 8까지를 제한 시간으로 두고 신호를 기다린다(대기blocked 상태가 된다).<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 6에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 7에서 태스크 2가 태스크 1을 중지suspend한다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 7에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 8에서 태스크 2가 태스크 1을 재시작resume한다.<br  />
 재시작resume되 태스크 1은 중지suspend되기 직전 상태인 대기blocked 상태가 된다.<br  />
 그리고 태스크 1이 이 시점까지를 제한 시간으로 두고 신호를 기다렸지만 중지suspend 상태에 머무른 시간은 지나간 시간으로 인정하지 않기 때문에 깨어나지 않는다.<br  />
 제한 시간이 다하는 시점은 중지suspend 상태에 머무른 시간을 더한 시점 9가 된다.<br  />
 따라서 여기까지 성공적으로 진행되었다면 확인 지점 8에서 태스크 2가 수행 중이어야 한다.<br  />
</p>
<p>시점 9가 되면 태스크 1이 제한 시간이 다해서 신호를 받지 못했더라도 깨어난다.<br  />
 여기까지 성공적으로 진행되었다면 확인 지점 9에서 태스크 1이 수행 중이어야 한다.<br  />
</p>
<p>시점 10에서 태스크 1이 종료된다.<br  />
</p>
<p>시점 11에서 태스크 2가 종료된다.<br  />
</p>
<div class="image">
<img src="ubik_test_tasktest09.gif" alt=""/>
</div>
<p> <br  />
</p>
<p>Content is available under Attribution-Noncommercial-No Derivative Works 3.0 Unported. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
